<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dart Eficiente: Estilo</title>
    </head>
    <body>
        <h2>Índice</h2>
        <ul>
            <li><a href="#orgc5f4382">1. Dart Eficiente: Estilo</a>
                <ul>
                    <li><a href="#org11ae969">1.1. Identificadores</a></li>
                    <li><a href="#org0a8894c">1.2. Faça: nomes de tipos com UpperCamelCase</a></li>
                    <li><a href="#orgbe4f227">1.3. Faça: nomes de extensões usando UpperCamelCase</a></li>
                    <li><a href="#org2a5d7da">1.4. Faça: nomeie pacotes, diretórios e código fonte usando lowercase_with_underscores.</a></li>
                    <li><a href="#org3e13df9">1.5. Faça: nomes de prefixos de importação usando lowercase_with_underscores</a></li>
                    <li><a href="#org0341307">1.6. Faça: nomes de outros identificadores usando lowerCamelCase</a></li>
                    <li><a href="#org67a7a4b">1.7. PREFIRA: usar lowerCamelCase em nomes de constantes</a>
                        <ul>
                            <li><a href="#org3d6844c">1.7.1. Nota:</a></li>
                        </ul>
                    </li>
                    <li><a href="#org9827668">1.8. FAÇA: Coloque siglas e abreviações em maiúscula com mais de duas letras, como palavras</a></li>
                    <li><a href="#org6f3648f">1.9. PREFIRA: usar <code>_</code>, <code>_ _</code>, etc. para parâmetros de callback não utilizados</a>
                        <ul>
                            <li><a href="#orgc4ce5b6">1.9.1. Nota:</a></li>
                        </ul>
                    </li>
                    <li><a href="#orga3edafe">1.10. NÃO use um sublinhado inicial para identificadores que não sejam privados</a></li>
                    <li><a href="#org37e310f">1.11. NÃO use letras de prefixo</a></li>
                    <li><a href="#org854412e">1.12. NÃO nomeie bibliotecas explicitamente</a></li>
                    <li><a href="#org6fdbfd0">1.13. Ordenando</a></li>
                    <li><a href="#org4b3593b">1.14. FAÇA: coloque importações dart: antes de outras importações</a></li>
                    <li><a href="#orgbc6eb63">1.15. FAÇA: coloque imports package: antes de imports relativos</a></li>
                    <li><a href="#orgf2acacf">1.16. FAÇA: especifique exports em uma seção separada após todos os imports</a></li>
                    <li><a href="#orgc8362d5">1.17. FAÇA: ordene seções alfabeticamente</a></li>
                    <li><a href="#org045a4ec">1.18. Formatação</a></li>
                    <li><a href="#orge8b5f9a">1.19. Formate seu código usando: dart format</a></li>
                    <li><a href="#org1f6e4eb">1.20. CONSIDERE: alterar seu código para torná-lo mais amigável ao formatador</a></li>
                    <li><a href="#org12d3836">1.21. EVITE: linhas mais longas do que 80 caracteres</a></li>
                    <li><a href="#org33129af">1.22. USE: chaves para todas as instruções de controle de fluxo</a></li>
                </ul>
            </li>
        </ul>
    
        <h2 id="orgc5f4382">1. <b>Dart</b> Eficiente: Estilo</h2>
        <p>
            Uma parte surpreendentemente importante de um bom código é o bom estilo. A nomenclatura, a ordem e a formatação consistentes ajudam o <mark>código igual</mark> a ter a <mark>mesma aparência</mark>. Ele aproveita o poderoso hardware de correspondência de padrões que a maioria de nós possui em nossos sistemas oculares. Se usarmos um estilo consistente em todo o ecossistema <b>Dart</b>, será mais fácil para todos nós aprendermos e contribuirmos com o código uns dos outros.
        </p>

        <h3 id="org11ae969">1.1. Identificadores</h3>

        <p>nota
            Os identificadores vêm em três sabores no <b>Dart</b>.
        </p>
    
        <ul class="org-ul">
            <li><span style="color:#11796d;">UpperCamelCase</span> nomes com a primeira letra de cada palavra em maiúscula, incluindo a primeira.</li>
            <li><span style="color: #11796d;">lowerCamelCase</span> nomes com a primeira letra de cada palavra em maiúscula, <i>exceto</i> a primeira letra.</li>
            <li><span style="color: #11796d;">lowercase_with_underscores</span> nomes que usam somente letras minúsculas, separadas por _.</li>
        </ul> 
    
        <h3 id="org0a8894c">1.2. Faça: nomes de tipos com <span style="color:#11796d;">UpperCamelCase</span></h3>
        <p>
            Nomes de classes, tipos enum, typedefs e parâmetros de tipos devem ter a primeira letra de cada palavra maiúscula (incluindo a primeira palavra) e não usar separadores.
        </p>
    
        <pre class="src src-dart">class SliderMenu { ... }
    
            class HttpRequest { ... }
    
            typedef Predicate&lt;T&gt; = bool Function(T value);
        </pre>
    
        <p>
            Isso inclui até classes destinadas a serem usadas em anotações de metadados.
        </p>
    

        <pre class="src src-dart">class Foo {
            const Foo([Object? arg]);
            }
    
            @Foo(anArg)
            class A { ... }
    
            @Foo()
            class B { ... }
        </pre>
    
        <p>
            Se o construtor da classe de anotação não aceitar parâmetros, talvez você queira criar uma constante <span style="color: #11796d;">lowerCamelCase</span> separada para ele.
        </p>
    
        <pre class="src src-dart">const foo = Foo();
    
            @foo
            class C { ... }
        </pre>
    
        <h3 id="orgbe4f227">1.3. Faça: nomes de extensões usando <span style="color:#11796d;">UpperCamelCase</span></h3>
        <p>
            Assim como os tipos, as extensões devem colocar a primeira letra de cada palavra em maiúscula (incluindo a primeira palavra) e não usar separadores.
        </p>
    
        <pre class="src src-dart">extension MyFancyList&lt;T&gt; on List&lt;T&gt; { ... }
    
            extension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; { ... }
        </pre>

        <h3 id="org2a5d7da">1.4. Faça: nomeie pacotes, diretórios e código fonte usando <span style="color: #11796d;">lowercase_with_underscores</span>.</h3>
        <p>
            Alguns sistemas de arquivos não diferenciam maiúsculas de minúsculas, portanto, muitos projetos exigem que os nomes dos arquivos estejam todos em letras minúsculas. Usar um caractere de separação permite que os nomes ainda possam ser lidos nesse formato. Usar sublinhados como separador garante que o nome ainda seja um identificador <b>Dart</b> válido, o que pode ser útil se a linguagem suportar posteriormente importações simbólicas.
        </p>
    
        <pre class="src src-bash"># bom:
            my_package
            └─ lib
                └─ file_system.dart
                └─ slider_menu.dart
        </pre>
    
        <pre class="src src-bash"># ruim:
            mypackage
            └─ lib
                └─ file-system.dart
                └─ SliderMenu.dart
        </pre>
    
        <h3 id="org3e13df9">1.5. Faça: nomes de prefixos de importação usando <span style="color: #11796d;">lowercase_with_underscores</span></h3>
    
        <pre class="src src-dart">// bom:
            import 'dart:math' as math;
            import 'package:angular_components/angular_components.dart' as angular_components;
            import 'package:js/js.dart' as js;
        </pre>
    
        <pre class="src src-dart">// ruim:
            import 'dart:math' as Math;
            import 'package:angular_components/angular_components.dart' as angularComponents;
            import 'package:js/js.dart' as JS;
        </pre>
    
        <h3 id="org0341307">1.6. Faça: nomes de outros identificadores usando <span style="color: #11796d;">lowerCamelCase</span></h3>
        <p>
            Membros de classe, definições de nível superior, variáveis, parâmetros e parâmetros nomeados devem ter a primeira letra de cada palavra em maiúscula, <i>exceto</i> a primeira palavra e não usar separadores.
        </p>
    
        <pre class="src src-dart">// bom:
            var count = 3;
    
            HttpRequest httpRequest;
    
            void align(bool clearItems) {
                // ...
            }
        </pre>
    
        <h3 id="org67a7a4b">1.7. PREFIRA: usar <span style="color: #11796d;">lowerCamelCase</span> em nomes de constantes</h3>
        <p>
            Em código novo, use <span style="color: #11796d;">lowerCamelCase</span> para variáveis ​​constantes, incluindo valores enum.
        </p>

        <pre class="src src-dart">// bom:
            const pi = 3.14;
            const defaultTimeout = 1000;
            final urlScheme = RegExp('^([a-z]+):');
    
            class Dice {
                tatic final numberGenerator = Random();
            }
        </pre>
    
        <pre class="src src-dart">// ruim:
            const PI = 3.14;
            const DefaultTimeout = 1000;
            final URL_SCHEME = RegExp('^([a-z]+):');
    
            class Dice {
                static final NUMBER_GENERATOR = Random();
            }
        </pre>
    
        <p>
            Você pode usar <small>SCREAMING_CAPS</small> para consistência com o código existente, como nos seguintes casos:
        </p> 
    
        <ul class="org-ul">
            <li>Ao adicionar código a um arquivo ou biblioteca que já usa o <small>SCREAMING_CAPS</small>.</li>
            <li>Ao gerar código <b>Dart</b> paralelo ao código <del>Java</del>, por exemplo, em tipos enumerados gerados a partir de protobufs.</li>
        </ul>
    
        <h4 id="org3d6844c">1.7.1. Nota:</h4>
        <blockquote style="color: lightsalmon;">
            <p>
                Inicialmente usavamos <small>SCREAMING_CAPS</small> no estilo <del>Java</del> para constantes. Mudamos por alguns motivos:
            </p> 
    
            <ul class="org-ul">
                <li><small>SCREAMING_CAPS</small> parece ruim em muitos casos, principalmente valores enum para coisas como cores CSS.</li>
                <li>As constantes são frequentemente alteradas para variáveis ​​finais não const, o que exigiria uma mudança de nome.</li>
                <li>A values propriedade definida automaticamente em um tipo enum é const e minúscula.</li>
            </ul>
        </blockquote>
        <h3 id="org9827668">1.8. Faça: Coloque siglas e <i>abreviações</i> em maiúscula com mais de duas letras, como palavras</h3>
    
        <p> 
            Acrônimos em maiúsculas podem ser difíceis de ler e vários acrônimos adjacentes podem levar a nomes ambíguos. Por exemplo, dado um nome que começa com HTTPSFTP, não há como saber se ele está se referindo a HTTPS FTP ou HTTP SFTP.
        </p>
    
        <p>
            Para evitar isso, siglas e abreviaturas são maiúsculas como palavras normais.
        </p>
    
        <p>
            Exceção: siglas de duas letras como IO (entrada/saída) são totalmente maiúsculas: IO. Por outro lado, <i>abreviações</i> de duas letras como ID (identificação) são como palavras normais: Id.
        </p>
    
        <pre class="src src-dart">// bom:
    
            class HttpConnection {}
            class DBIOPort {}
            class TVVcr {}
            class MrRogers {}
    
            var httpRequest = ...
            var uiHandler = ...
            var userId = ...
            Id id;
        </pre>
    
        <pre class="src src-dart">// ruim:
    
            class HTTPConnection {}
            class DbIoPort {}
            class TvVcr {}
            class MRRogers {}
    
            var hTTPRequest = ...
            var uIHandler = ...
            var userID = ...
            ID iD;
        </pre>
    
        <h3 id="org6f3648f">1.9. PREFIRA: usar <code>_</code>, <code>_ _</code>, etc. para parâmetros de callback não utilizados</h3>
        <p>
            Às vezes, a assinatura de tipo de uma função <ins>callback</ins> requer um parâmetro, mas a implementação da <ins>callback</ins> não usa o parâmetro. Nesse caso, é idiomático nomear o parâmetro não utilizado <code>_</code>. Se a função tiver vários parâmetros não utilizados, use sublinhados adicionais para evitar colisões de nomes: <code>_</code> <code>_</code>, <code>_</code> <code>_</code> <code>_</code>, etc.
        </p>
    
        <pre class="src src-dart">// bom:
            futureOfVoid.then((_) {
                print('Operation complete.');
            });
        </pre>
    
        <p>
            Esta diretriz é apenas para funções anônimas e locais. Essas funções geralmente são usadas imediatamente em um contexto onde está claro o que o parâmetro não utilizado representa. Por outro lado, funções de nível superior e declarações de métodos não têm esse contexto, portanto seus parâmetros devem ser nomeados para que fique claro para que serve cada parâmetro, mesmo que não seja usado.
        </p>
    
        <h4 id="orgc4ce5b6">1.9.1. Nota:</h4>
        <blockquote style="color: lightsalmon;">
            <!-- <p>
                De acordo com o gemini:
            </p> -->
    
            <p>
                No Flutter, uma <ins>callback</ins> é uma função que você passa como argumento para outra função. Essa função passada é então chamada posteriormente pela função que a recebeu, em um momento específico, como por exemplo:
            </p>
    
            <ul class="org-ul">
                <li>Quando um evento ocorre (ex.: clique de um botão, finalização de uma animação).</li>
                <li>Quando uma operação assíncrona é concluída (ex.: download de um arquivo, requisição de dados a uma API).</li>
            </ul>
    
            <p>
                Callbacks são um mecanismo fundamental para lidar com assincronismo no Flutter, pois permitem que você execute código depois que uma operação termine, ao invés de ficar esperando de forma síncrona.
            </p>
    
            <p>
                Aqui estão alguns exemplos de uso de <ins>callback</ins> no Flutter:
            </p>
    
            <ul class="org-ul">
                <li>Um widget onPressed <ins>callback</ins> é usado para especificar o código que deve ser executado quando um botão é pressionado.</li>
                <li>Um widget FutureBuilder utiliza um <ins>callback</ins> para definir o que deve ser renderizado após a conclusão de uma operação assíncrona.</li>
            </ul>
    
            <p>
                Usar <ins>callback</ins> ajuda a manter seu código organizado e evita o uso de técnicas de bloqueio, o que pode prejudicar o desempenho do seu aplicativo.
            </p>
    
        </blockquote>
        <h3 id="orga3edafe">1.10. NÃO use um sublinhado inicial para identificadores que não sejam privados</h3>
        <p>
            O <b>Dart</b> usa um sublinhado inicial em um identificador para marcar membros e declarações de nível superior como privados. Isso treina os usuários para associar um sublinhado inicial a um desses tipos de declaração. Eles veem “_” e pensam “privado”.
        </p>
    
        <p>
            Não existe conceito de "privado" para variáveis ​​locais, parâmetros, funções locais ou prefixos de biblioteca. Quando um deles tem um nome que começa com sublinhado, envia um sinal confuso ao leitor. Para evitar isso, não use sublinhados iniciais nesses nomes.
        </p>
    
        <h3 id="org37e310f">1.11. NÃO use letras de prefixo</h3>
        <p>
            A notação húngara e outros esquemas surgiram na época da BCPL, quando o compilador não fazia muito para ajudá-lo a entender seu código. Como o <b>Dart</b> pode informar o tipo, o escopo, a mutabilidade e outras propriedades de suas declarações, não há razão para codificar essas propriedades em nomes de identificadores.
        </p>
    
        <pre class="src src-dart">// bom:
            defaultTimeout
        </pre>
    
        <pre class="src src-dart">// ruim:
            kDefaultTimeout
        </pre>
    
        <h3 id="org854412e">1.12. NÃO nomeie bibliotecas explicitamente</h3>
        <p>
            Acrescentar um nome à library diretiva é tecnicamente possível, mas é um recurso legado e não é recomendado.
        </p>
    
        <p>
            O <b>Dart</b> gera uma tag exclusiva para cada biblioteca com base em seu caminho e nome de arquivo. A nomeação de bibliotecas substitui esse URI gerado. Sem o URI, pode ser mais difícil para as ferramentas encontrarem o arquivo da biblioteca principal em questão.
        </p>
    
        <pre class="src src-dart">// ruim:
    
            library my_library;
        </pre>
    
        <pre class="src src-dart">// bom:
    
            /// A really great test library.
            @TestOn('browser')
            library;
        </pre>
    
        <h3 id="org6fdbfd0">1.13. Ordenando</h3>
        <p>
            Para manter o preâmbulo do seu arquivo organizado, temos uma ordem prescrita na qual as diretivas devem aparecer. Cada "seção" deve ser separada por uma linha em branco.
        </p>
    
        <p>
            Uma única regra de linter lida com todas as diretrizes de pedido: directivas_ordering.
        </p>
    
        <h3 id="org4b3593b">1.14. FAÇA: coloque importações <b>dart</b>: antes de outras importações</h3>
        <pre class="src src-dart">// bom:
    
            import 'dart:async';
            import 'dart:html';
    
            import 'package:bar/bar.dart';
            import 'package:foo/foo.dart';
        </pre>
    
        <h3 id="orgbc6eb63">1.15. FAÇA: coloque imports package: antes de imports relativos</h3>
        <pre class="src src-dart">import 'package:bar/bar.dart';
            import 'package:foo/foo.dart';
    
            import 'util.dart';
        </pre>
    
        <h3 id="orgf2acacf">1.16. FAÇA: especifique exports em uma seção separada após todos os imports</h3>
        <pre class="src src-dart">// bom:
    
            import 'src/error.dart';
            import 'src/foo_bar.dart';
    
            export 'src/error.dart';
        </pre>
    
        <pre class="src src-dart">// ruim:
    
            import 'src/error.dart';
            export 'src/error.dart';
            import 'src/foo_bar.dart';
        </pre>
    
        <h3 id="orgc8362d5">1.17. FAÇA: ordene seções alfabeticamente</h3>
        <pre class="src src-dart">// bom:
    
            import 'package:bar/bar.dart';
            import 'package:foo/foo.dart';
    
            import 'foo.dart';
            import 'foo/foo.dart';
        </pre>
    
        <pre class="src src-dart">// ruim:
    
            import 'package:foo/foo.dart';
            import 'package:bar/bar.dart';
    
            import 'foo/foo.dart';
            import 'foo.dart';
        </pre>
    
        <h3 id="org045a4ec">1.18. Formatação</h3>
        <p>
            Como muitas linguagens, o <b>Dart</b> ignora os espaços em branco. No entanto, os <i>humanos</i> não. Ter um estilo de espaço em branco consistente ajuda a garantir que os leitores <i>humanos</i> vejam o código da mesma forma que o compilador.
        </p>
    
        <h3 id="orge8b5f9a">1.19. Formate seu código usando: <b>dart</b> format</h3>
        <p>
            A formatação é um trabalho tedioso e particularmente demorado durante a refatoração. Felizmente, você não precisa se preocupar com isso. Fornecemos um sofisticado formatador de código automatizado chamado <b>dart</b> format que faz isso por você. Temos alguma documentação sobre as regras que ela aplica, mas as regras oficiais de tratamento de espaços em branco para o <b>Dart</b> são aquelas que <b>dart</b> format produzem.
        </p>
    
        <p>
            O restante dos guias de formatação são para as poucas coisas que <b>dart</b> format não consegue corrigir por você.
        </p>
    
        <h3 id="org1f6e4eb">1.20. CONSIDERE: alterar seu código para torná-lo mais amigável ao formatador</h3>
        <p>
            O formatador faz o melhor que pode com qualquer código que você usa, mas não pode fazer milagres. Se o seu código tiver identificadores particularmente longos, expressões profundamente aninhadas, uma mistura de diferentes tipos de operadores, etc., a saída formatada ainda poderá ser difícil de ler.
        </p>
    
        <p>
            Quando isso acontecer, reorganize ou simplifique seu código. Considere encurtar o nome de uma variável local ou transformar uma expressão em uma nova variável local. Em outras palavras, faça os mesmos tipos de modificações que você faria se estivesse formatando o código manualmente e tentando torná-lo mais legível. Pense no <b>dart</b> format como uma parceria onde vocês trabalham juntos, às vezes de forma iterativa, para produzir um código bonito.
        </p>
    
        <h3 id="org12d3836">1.21. EVITE: linhas mais longas do que 80 caracteres</h3>
        <p>
            Estudos de legibilidade mostram que longas linhas de texto são mais difíceis de ler porque seu olho precisa se deslocar mais longe ao passar para o início da linha seguinte. É por isso que jornais e revistas usam múltiplas colunas de texto.
        </p>
    
        <p>
            Se você realmente deseja linhas com mais de 80 caracteres, nossa experiência é que seu código provavelmente é muito detalhado e pode ser um pouco mais compacto. O principal bandido geralmente é NomeDeClassesMuitoLongs. Pergunte a si mesmo: "Cada palavra nesse nome de tipo me diz algo crítico ou evita uma colisão de nomes?" Caso contrário, considere omiti-lo.
        </p>
    
        <p>
            Observe que o dart format faz 99% do trabalho para você, mas o último 1% é você. Ele não divide literais de strings longas para caber em 80 colunas, então você precisa fazer isso manualmente.
        </p>
    
        <p>
            Exceção: quando um URI ou caminho de arquivo ocorre em um comentário ou string (geralmente em uma importação ou exportação), ele pode permanecer inteiro mesmo que faça com que a linha ultrapasse 80 caracteres. Isso torna mais fácil pesquisar um caminho nos arquivos de origem.
        </p>
    
        <p>
            Exceção: strings multilinhas podem conter linhas com mais de 80 caracteres porque as novas linhas são significativas dentro da string e dividir as linhas em linhas mais curtas pode alterar o programa.
        </p>
    
        <h3 id="org33129af">1.22. USE: chaves para todas as instruções de controle de fluxo</h3>
        <p>
            Fazendo assim você evita o problema do else pendente.
        </p>
    
        <pre class="src src-dart">if (ehDiaSemana) {
                print('Bicicleta para o trabalho!');
            } else {
                print('Vá dançar ou leia um livro!');
            }
        </pre>
    
        <p>
            Exceção: quando você tem uma instrução if sem cláusula else e toda a instrução if cabe em uma linha, você pode omitir os colchetes se preferir:
        </p>
    
        <pre class="src src-dart">// bom:
    
            if (arg == null) return defaultValue;
        </pre>
    
        <p>
            Porém, se o corpo passar para a próxima linha, use colchetes:
        </p>
    
        <pre class="src src-dart">// bom:
    
            if (overflowChars != other.overflowChars) {
                return overflowChars &lt; other.overflowChars;
            }
        </pre>
    
        <pre class="src src-dart">// ruim:
    
            if (overflowChars != other.overflowChars)
                return overflowChars &lt; other.overflowChars;
        </pre>
        <a href="#orgc5f4382">Voltar para <b>Dart</b> Eficiente: Estilo</a>
    </body>
</html>
